# Why services fail even when permissions look correct ← NEXT

# Step 1: Create a fake service user

sudo useradd -r -s /usr/sbin/nologin appuser

This user:
Cannot log in
Mimics real services (nginx, postgres, etc.)

# Step 2: Create an app directory.

sudo mkdir /opt/app
sudo chown root:root /opt/app
sudo chmod 755 /opt/app

So far, everything looks “normal”.

# Step 3: Create a writable subdirectory

sudo mkdir /opt/app/data
sudo chown appuser:appuser /opt/app/data
sudo chmod 700 /opt/app/data

Looks perfect, right?
Owner: appuser
Permissions: rwx
No one else can touch it

# The failure (this is intentional)

Now simulate the service:

sudo -u appuser touch /opt/app/data/testfile

It works.
Now try:

sudo -u appuser touch /opt/app/data/../failfile

This should FAIL


###### Answer
To access any path, Linux checks permissions one directory at a time, from left to right.
For this command:

/opt/app/data/../failfile


Linux evaluates:
/ → ok
/opt → ok
/opt/app → ❌ BLOCKED HERE
/opt/app/data → never reached

# Why?
Because execute (x) permission on a directory means “you may pass through”.


# What Linux actually checks

Let’s map permissions:

/opt        -> usually 755
/opt/app    -> 755 root:root
/opt/app/data -> 700 appuser:appuser


# When running as appuser:
/opt/app/data → ✔️ rwx
/opt/app → ❌ no write

But here’s the key:
Creating failfile means writing into /opt/app, not into data
The .. resolves before permissions are applied.

So Linux sees this as:
touch /opt/app/failfile


And /opt/app is:
Owned by root
Writable only by root
So the operation is denied..


# real rule is:
Write without execute = powerless
Execute without write = access but no modification
Write + execute = creation/deletion allowed